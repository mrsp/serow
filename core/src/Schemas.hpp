#pragma once

#include <filesystem>
#include <string>

#include "mcap/mcap.hpp"

namespace serow {

// Create a schema for PointCloud
static inline mcap::Schema createPointCloudSchema() {
    mcap::Schema schema;
    schema.name = "foxglove.PointCloud";
    schema.encoding = "jsonschema";
    std::string schema_data = R"({
        "title": "foxglove.PointCloud",
        "description": "A collection of N-dimensional points, which may contain additional fields with information like normals, intensity, etc.",
        "$comment": "Generated by https://github.com/foxglove/foxglove-sdk",
        "type": "object",
        "properties": {
            "timestamp": {
                "type": "object",
                "title": "time",
                "properties": {
                    "sec": {
                        "type": "integer",
                        "minimum": 0
                    },
                    "nsec": {
                        "type": "integer",
                        "minimum": 0,
                        "maximum": 999999999
                    }
                },
                "description": "Timestamp of point cloud"
            },
            "frame_id": {
                "type": "string",
                "description": "Frame of reference"
            },
            "pose": {
                "title": "foxglove.Pose",
                "description": "The origin of the point cloud relative to the frame of reference",
                "type": "object",
                "properties": {
                    "position": {
                        "title": "foxglove.Vector3",
                        "description": "Point denoting position in 3D space",
                        "type": "object",
                        "properties": {
                            "x": {
                                "type": "number",
                                "description": "x coordinate length"
                            },
                            "y": {
                                "type": "number",
                                "description": "y coordinate length"
                            },
                            "z": {
                                "type": "number",
                                "description": "z coordinate length"
                            }
                        }
                    },
                    "orientation": {
                        "title": "foxglove.Quaternion",
                        "description": "Quaternion denoting orientation in 3D space",
                        "type": "object",
                        "properties": {
                            "x": {
                                "type": "number",
                                "description": "x value"
                            },
                            "y": {
                                "type": "number",
                                "description": "y value"
                            },
                            "z": {
                                "type": "number",
                                "description": "z value"
                            },
                            "w": {
                                "type": "number",
                                "description": "w value"
                            }
                        }
                    }
                }
            },
            "point_stride": {
                "type": "integer",
                "minimum": 0,
                "description": "Number of bytes between points in the `data`"
            },
            "fields": {
                "type": "array",
                "items": {
                    "title": "foxglove.PackedElementField",
                    "description": "A field present within each element in a byte array of packed elements.",
                    "type": "object",
                    "properties": {
                        "name": {
                            "type": "string",
                            "description": "Name of the field"
                        },
                        "offset": {
                            "type": "integer",
                            "minimum": 0,
                            "description": "Byte offset from start of data buffer"
                        },
                        "type": {
                            "title": "foxglove.NumericType",
                            "description": "Type of data in the field. Integers are stored using little-endian byte order.",
                            "oneOf": [
                                {
                                    "title": "UNKNOWN",
                                    "const": 0
                                },
                                {
                                    "title": "UINT8",
                                    "const": 1
                                },
                                {
                                    "title": "INT8",
                                    "const": 2
                                },
                                {
                                    "title": "UINT16",
                                    "const": 3
                                },
                                {
                                    "title": "INT16",
                                    "const": 4
                                },
                                {
                                    "title": "UINT32",
                                    "const": 5
                                },
                                {
                                    "title": "INT32",
                                    "const": 6
                                },
                                {
                                    "title": "FLOAT32",
                                    "const": 7
                                },
                                {
                                    "title": "FLOAT64",
                                    "const": 8
                                }
                            ]
                        }
                    }
                },
                "description": "Fields in `data`. At least 2 coordinate fields from `x`, `y`, and `z` are required for each point's position; `red`, `green`, `blue`, and `alpha` are optional for customizing each point's color."
            },
            "data": {
                "type": "string",
                "contentEncoding": "base64",
                "description": "Point data, interpreted using `fields`"
            }
        }
    })";
    schema.data = mcap::ByteArray(
        reinterpret_cast<const std::byte*>(schema_data.data()),
        reinterpret_cast<const std::byte*>(schema_data.data() + schema_data.size()));
    return schema;
}

// Create a schema for tfs
static inline mcap::Schema createTFSchema() {
    mcap::Schema schema;
    schema.name = "foxglove.FrameTransform";
    schema.encoding = "jsonschema";
    std::string schema_data = R"({
        "title": "foxglove.FrameTransform",
        "description": "A transform between two reference frames in 3D space",
        "$comment": "Generated by https://github.com/foxglove/foxglove-sdk",
        "type": "object",
        "properties": {
            "timestamp": {
                "type": "object",
                "title": "time",
                "properties": {
                    "sec": {
                        "type": "integer",
                        "minimum": 0
                    },
                    "nsec": {
                        "type": "integer",
                        "minimum": 0,
                        "maximum": 999999999
                    }
                },
                "description": "Timestamp of transform"
            },
            "parent_frame_id": {
                "type": "string",
                "description": "Name of the parent frame"
            },
            "child_frame_id": {
                "type": "string",
                "description": "Name of the child frame"
            },
            "translation": {
                "title": "foxglove.Vector3",
                "description": "Translation component of the transform",
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "x coordinate length"
                    },
                    "y": {
                        "type": "number",
                        "description": "y coordinate length"
                    },
                    "z": {
                        "type": "number",
                        "description": "z coordinate length"
                    }
                }
            },
            "rotation": {
                "title": "foxglove.Quaternion",
                "description": "Rotation component of the transform",
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "x value"
                    },
                    "y": {
                        "type": "number",
                        "description": "y value"
                    },
                    "z": {
                        "type": "number",
                        "description": "z value"
                    },
                    "w": {
                        "type": "number",
                        "description": "w value"
                    }
                }
            }
        }
    })";
    schema.data = mcap::ByteArray(
        reinterpret_cast<const std::byte*>(schema_data.data()),
        reinterpret_cast<const std::byte*>(schema_data.data() + schema_data.size()));
    return schema;
}

// Create a schema for an array of tfs
static inline mcap::Schema createFrameTransformsSchema() {
    mcap::Schema schema;
    schema.name = "foxglove.FrameTransforms";
    schema.encoding = "jsonschema";
    std::string schema_data = R"({
        "title": "foxglove.FrameTransforms",
        "description": "An array of FrameTransform messages",
        "$comment": "Generated by https://github.com/foxglove/foxglove-sdk",
        "type": "object",
        "properties": {
            "transforms": {
                "type": "array",
                "items": {
                    "title": "foxglove.FrameTransform",
                    "description": "A transform between two reference frames in 3D space",
                    "type": "object",
                    "properties": {
                        "timestamp": {
                            "type": "object",
                            "title": "time",
                            "properties": {
                                "sec": {
                                    "type": "integer",
                                    "minimum": 0
                                },
                                "nsec": {
                                    "type": "integer",
                                    "minimum": 0,
                                    "maximum": 999999999
                                }
                            },
                            "description": "Timestamp of transform"
                        },
                        "parent_frame_id": {
                            "type": "string",
                            "description": "Name of the parent frame"
                        },
                        "child_frame_id": {
                            "type": "string",
                            "description": "Name of the child frame"
                        },
                        "translation": {
                            "title": "foxglove.Vector3",
                            "description": "Translation component of the transform",
                            "type": "object",
                            "properties": {
                                "x": {
                                    "type": "number",
                                    "description": "x coordinate length"
                                },
                                "y": {
                                    "type": "number",
                                    "description": "y coordinate length"
                                },
                                "z": {
                                    "type": "number",
                                    "description": "z coordinate length"
                                }
                            }
                        },
                        "rotation": {
                            "title": "foxglove.Quaternion",
                            "description": "Rotation component of the transform",
                            "type": "object",
                            "properties": {
                                "x": {
                                    "type": "number",
                                    "description": "x value"
                                },
                                "y": {
                                    "type": "number",
                                    "description": "y value"
                                },
                                "z": {
                                    "type": "number",
                                    "description": "z value"
                                },
                                "w": {
                                    "type": "number",
                                    "description": "w value"
                                }
                            }
                        }
                    }
                },
                "description": "Array of transforms"
            }
        }
    })";
    schema.data = mcap::ByteArray(
        reinterpret_cast<const std::byte*>(schema_data.data()),
        reinterpret_cast<const std::byte*>(schema_data.data() + schema_data.size()));
    return schema;
}

static inline mcap::Schema createBaseStateSchema() {
    mcap::Schema schema;
    schema.name = "BaseState";
    schema.encoding = "jsonschema";
    std::string schema_data =
        "{"
        "    \"type\": \"object\","
        "    \"properties\": {"
        "        \"timestamp\": {"
        "            \"type\": \"number\","
        "            \"description\": \"Timestamp of the state (s)\""
        "        },"
        "        \"base_position\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"3D Base position in world frame coordinates (m)\""
        "        },"
        "        \"base_orientation\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 4,"
        "            \"maxItems\": 4,"
        "            \"description\": \"Base orientation quaternion [w, x, y, z] in world "
        "frame coordinates\""
        "        },"
        "        \"base_linear_velocity\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"3D Base linear velocity in world frame coordinates "
        "(m/s)\""
        "        },"
        "        \"base_angular_velocity\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"3D Base angular velocity in world frame coordinates "
        "(rad/s)\""
        "        },"
        "        \"base_linear_acceleration\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"3D Base linear acceleration in world frame coordinates "
        "(m/s^2)\""
        "        },"
        "        \"base_angular_acceleration\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"3D Base angular acceleration in world frame "
        "coordinates (rad/s^2)\""
        "        },"
        "        \"imu_linear_acceleration_bias\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"3D IMU linear acceleration bias in IMU frame "
        "coordinates (m/s^2)\""
        "        },"
        "        \"imu_angular_velocity_bias\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"3D IMU angular velocity bias in IMU frame coordinates "
        "(rad/s)\""
        "        },"
        "        \"num_contacts\": {"
        "            \"type\": \"integer\","
        "            \"description\": \"Number of contact points\""
        "        },"
        "        \"contact_names\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"string\""
        "            },"
        "            \"description\": \"Array of contact point names\""
        "        },"
        "        \"contacts\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"object\","
        "                \"properties\": {"
        "                    \"name\": {"
        "                        \"type\": \"string\","
        "                        \"description\": \"Contact point name\""
        "                    },"
        "                    \"position\": {"
        "                        \"type\": \"array\","
        "                        \"items\": {"
        "                            \"type\": \"number\""
        "                        },"
        "                        \"minItems\": 3,"
        "                        \"maxItems\": 3,"
        "                        \"description\": \"3D contact position in world frame "
        "coordinates (m)\""
        "                    },"
        "                    \"foot_position\": {"
        "                        \"type\": \"array\","
        "                        \"items\": {"
        "                            \"type\": \"number\""
        "                        },"
        "                        \"minItems\": 3,"
        "                        \"maxItems\": 3,"
        "                        \"description\": \"3D foot position in world frame "
        "coordinates (m)\""
        "                    },"
        "                    \"foot_orientation\": {"
        "                        \"type\": \"array\","
        "                        \"items\": {"
        "                            \"type\": \"number\""
        "                        },"
        "                        \"minItems\": 4,"
        "                        \"maxItems\": 4,"
        "                        \"description\": \"Foot orientation quaternion [w, x, y, z] "
        "in world frame coordinates\""
        "                    },"
        "                    \"foot_linear_velocity\": {"
        "                        \"type\": \"array\","
        "                        \"items\": {"
        "                            \"type\": \"number\""
        "                        },"
        "                        \"minItems\": 3,"
        "                        \"maxItems\": 3,"
        "                        \"description\": \"3D foot linear velocity in world frame "
        "coordinates (m/s)\""
        "                    },"
        "                    \"foot_angular_velocity\": {"
        "                        \"type\": \"array\","
        "                        \"items\": {"
        "                            \"type\": \"number\""
        "                        },"
        "                        \"minItems\": 3,"
        "                        \"maxItems\": 3,"
        "                        \"description\": \"3D foot angular velocity in world frame "
        "coordinates (rad/s)\""
        "                    }"
        "                },"
        "                \"required\": [\"name\", \"position\"]"
        "            },"
        "            \"description\": \"Array of contact data objects\""
        "        }"
        "    },"
        "    \"required\": [\"timestamp\", \"base_position\", \"base_orientation\", "
        "\"base_linear_velocity\", \"base_angular_velocity\", \"base_linear_acceleration\", "
        "\"base_angular_acceleration\", \"imu_linear_acceleration_bias\", "
        "\"imu_angular_velocity_bias\", \"num_contacts\", \"contact_names\", \"contacts\"]"
        "}";

    schema.data = mcap::ByteArray(
        reinterpret_cast<const std::byte*>(schema_data.data()),
        reinterpret_cast<const std::byte*>(schema_data.data() + schema_data.size()));
    return schema;
}

static inline mcap::Schema createCentroidalStateSchema() {
    mcap::Schema schema;
    schema.name = "CentroidalState";
    schema.encoding = "jsonschema";
    std::string schema_data =
        "{"
        "    \"type\": \"object\","
        "    \"properties\": {"
        "        \"timestamp\": {"
        "            \"type\": \"number\","
        "            \"description\": \"Timestamp of the state (s)\""
        "        },"
        "        \"com_position\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"3D CoM position in world frame coordinates (m)\""
        "        },"
        "        \"com_linear_velocity\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"3D CoM linear velocity in world frame coordinates "
        "(m/s)\""
        "        },"
        "        \"external_forces\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"3D External forces at the CoM in world frame "
        "coordinates (N)\""
        "        },"
        "        \"cop_position\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"3D COP position in world frame coordinates (m)\""
        "        },"
        "        \"com_linear_acceleration\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"3D CoM linear acceleration in world frame coordinates "
        "(m/s^2)\""
        "        },"
        "        \"angular_momentum\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"3D Angular momentum around the CoM in world frame "
        "coordinates (kg m^2/s)\""
        "        },"
        "        \"angular_momentum_derivative\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"3D Angular momentum derivative around the CoM in world "
        "frame coordinates (Nm)\""
        "        }"
        "    },"
        "    \"required\": [\"timestamp\", \"com_position\", \"com_linear_velocity\", "
        "\"external_forces\", \"cop_position\", \"com_linear_acceleration\", "
        "\"angular_momentum\", \"angular_momentum_derivative\"]"
        "}";

    schema.data = mcap::ByteArray(
        reinterpret_cast<const std::byte*>(schema_data.data()),
        reinterpret_cast<const std::byte*>(schema_data.data() + schema_data.size()));
    return schema;
}

static inline mcap::Schema createJointMeasurementSchema() {
    mcap::Schema schema;
    schema.name = "JointMeasurement";
    schema.encoding = "jsonschema";
    std::string schema_data =
        "{"
        "    \"type\": \"object\","
        "    \"properties\": {"
        "        \"timestamp\": {"
        "            \"type\": \"number\","
        "            \"description\": \"Timestamp of the measurement (s)\""
        "        },"
        "        \"num_joints\": {"
        "            \"type\": \"integer\","
        "            \"description\": \"Number of joints in the measurement\""
        "        },"
        "        \"joint_names\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"string\""
        "            },"
        "            \"description\": \"Array of joint names\""
        "        },"
        "        \"joints\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"object\","
        "                \"properties\": {"
        "                    \"position\": {"
        "                        \"type\": \"number\","
        "                        \"description\": \"Joint position (rad)\""
        "                    },"
        "                    \"velocity\": {"
        "                        \"type\": \"number\","
        "                        \"description\": \"Joint velocity (rad/s)\""
        "                    }"
        "                },"
        "                \"required\": [\"position\"]"
        "            }"
        "        }"
        "    },"
        "    \"required\": [\"timestamp\", \"num_joints\", \"joint_names\", \"joints\"]"
        "}";

    schema.data = mcap::ByteArray(
        reinterpret_cast<const std::byte*>(schema_data.data()),
        reinterpret_cast<const std::byte*>(schema_data.data() + schema_data.size()));
    return schema;
}

static inline mcap::Schema createForceTorqueMeasurementSchema() {
    mcap::Schema schema;
    schema.name = "ForceTorqueMeasurement";
    schema.encoding = "jsonschema";
    std::string schema_data =
        "{"
        "    \"type\": \"object\","
        "    \"properties\": {"
        "        \"timestamp\": {"
        "            \"type\": \"number\","
        "            \"description\": \"Timestamp of the measurement (s)\""
        "        },"
        "        \"num_sensors\": {"
        "            \"type\": \"integer\","
        "            \"description\": \"Number of force-torque sensors in the measurement\""
        "        },"
        "        \"sensor_names\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"string\""
        "            },"
        "            \"description\": \"Array of force-torque sensor names\""
        "        },"
        "        \"sensors\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"object\","
        "                \"properties\": {"
        "                    \"force\": {"
        "                        \"type\": \"array\","
        "                        \"items\": {"
        "                            \"type\": \"number\""
        "                        },"
        "                        \"minItems\": 3,"
        "                        \"maxItems\": 3,"
        "                        \"description\": \"Force measured by force-torque sensor (N)\""
        "                    },"
        "                    \"cop\": {"
        "                        \"type\": \"array\","
        "                        \"items\": {"
        "                            \"type\": \"number\""
        "                        },"
        "                        \"minItems\": 3,"
        "                        \"maxItems\": 3,"
        "                        \"description\": \"Center of pressure (COP) measured by "
        "force-torque sensor (m)\""
        "                    },"
        "                    \"torque\": {"
        "                        \"type\": \"array\","
        "                        \"items\": {"
        "                            \"type\": \"number\""
        "                        },"
        "                        \"minItems\": 3,"
        "                        \"maxItems\": 3,"
        "                        \"description\": \"Optional torque measured by force-torque "
        "sensor (Nm)\""
        "                    }"
        "                },"
        "                \"required\": [\"force\", \"cop\"]"
        "            }"
        "        }"
        "    },"
        "    \"required\": [\"timestamp\", \"num_sensors\", \"sensor_names\", \"sensors\"]"
        "}";

    schema.data = mcap::ByteArray(
        reinterpret_cast<const std::byte*>(schema_data.data()),
        reinterpret_cast<const std::byte*>(schema_data.data() + schema_data.size()));
    return schema;
}

static inline mcap::Schema createContactStateSchema() {
    mcap::Schema schema;
    schema.name = "ContactState";
    schema.encoding = "jsonschema";
    std::string schema_data =
        "{"
        "    \"type\": \"object\","
        "    \"properties\": {"
        "        \"timestamp\": {"
        "            \"type\": \"number\","
        "            \"description\": \"Timestamp of the state (s)\""
        "        },"
        "        \"num_contacts\": {"
        "            \"type\": \"integer\","
        "            \"description\": \"Number of contact points\""
        "        },"
        "        \"contact_names\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"string\""
        "            },"
        "            \"description\": \"Array of contact point names\""
        "        },"
        "        \"contacts\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"object\","
        "                \"properties\": {"
        "                    \"status\": {"
        "                        \"type\": \"boolean\","
        "                        \"description\": \"Contact status (true if in contact)\""
        "                    },"
        "                    \"probability\": {"
        "                        \"type\": \"number\","
        "                        \"description\": \"Contact probability (0-1)\""
        "                    },"
        "                    \"force\": {"
        "                        \"type\": \"array\","
        "                        \"items\": {"
        "                            \"type\": \"number\""
        "                        },"
        "                        \"minItems\": 3,"
        "                        \"maxItems\": 3,"
        "                        \"description\": \"3D Contact force in world frame "
        "coordinates (N)\""
        "                    },"
        "                    \"torque\": {"
        "                        \"type\": \"array\","
        "                        \"items\": {"
        "                            \"type\": \"number\""
        "                        },"
        "                        \"minItems\": 3,"
        "                        \"maxItems\": 3,"
        "                        \"description\": \"3D Contact torque in world frame "
        "coordinates (Nm)\""
        "                    }"
        "                },"
        "                \"required\": [\"status\", \"probability\", \"force\"]"
        "            }"
        "        }"
        "    },"
        "    \"required\": [\"timestamp\", \"num_contacts\", \"contact_names\", \"contacts\"]"
        "}";

    schema.data = mcap::ByteArray(
        reinterpret_cast<const std::byte*>(schema_data.data()),
        reinterpret_cast<const std::byte*>(schema_data.data() + schema_data.size()));
    return schema;
}

static inline mcap::Schema createImuMeasurementSchema() {
    mcap::Schema schema;
    schema.name = "ImuMeasurement";
    schema.encoding = "jsonschema";
    std::string schema_data =
        "{"
        "    \"type\": \"object\","
        "    \"properties\": {"
        "        \"timestamp\": {"
        "            \"type\": \"number\","
        "            \"description\": \"Timestamp of the measurement (s)\""
        "        },"
        "        \"linear_acceleration\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"Linear acceleration in x, y, z (m/s^2)\""
        "        },"
        "        \"angular_velocity\": {"
        "            \"type\": \"array\","
        "            \"items\": {"
        "                \"type\": \"number\""
        "            },"
        "            \"minItems\": 3,"
        "            \"maxItems\": 3,"
        "            \"description\": \"Angular velocity in x, y, z (rad/s)\""
        "        }"
        "    },"
        "    \"required\": [\"timestamp\", \"linear_acceleration\", \"angular_velocity\"]"
        "}";

    schema.data = mcap::ByteArray(
        reinterpret_cast<const std::byte*>(schema_data.data()),
        reinterpret_cast<const std::byte*>(schema_data.data() + schema_data.size()));
    return schema;
}

static inline mcap::Schema createSceneEntitySchema() {
    // Load the .bfbs file
    std::string bfbs_path = "SceneEntity.bfbs";

    // Add the source directory path if defined
#ifdef SCHEMAS_DIR
    bfbs_path = std::filesystem::path(SCHEMAS_DIR) / "SceneEntity.bfbs";
#endif
    std::ifstream schema_file(bfbs_path, std::ios::binary);
    if (!schema_file.is_open()) {
        throw std::runtime_error("Failed to open SceneEntity.bfbs at " + bfbs_path);
    }

    // Read the entire file into a vector
    std::vector<uint8_t> schema_data((std::istreambuf_iterator<char>(schema_file)),
                                     std::istreambuf_iterator<char>());
    schema_file.close();

    if (schema_data.empty()) {
        throw std::runtime_error("SceneEntity.bfbs is empty");
    }

    // Define SceneEntity schema using .bfbs data
    mcap::Schema schema;
    schema.name = "foxglove.SceneEntity";
    schema.encoding = "flatbuffer";
    schema.data = mcap::ByteArray(
        reinterpret_cast<const std::byte*>(schema_data.data()),
        reinterpret_cast<const std::byte*>(schema_data.data() + schema_data.size()));
    return schema;
}

}  // namespace serow
